package io.swagger.model;

import java.util.Objects;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import javax.validation.constraints.*;
/**
 * InlineResponse200EventsPeriodic
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.SpringCodegen", date = "2017-05-12T22:37:00.102Z")

public class InlineResponse200EventsPeriodic   {
  @JsonProperty("start")
  private String start = null;

  @JsonProperty("end")
  private String end = null;

  @JsonProperty("interval")
  private Integer interval = null;

  public InlineResponse200EventsPeriodic start(String start) {
    this.start = start;
    return this;
  }

   /**
   * The date and time when the timing object starts to create triggers.
   * @return start
  **/
  @ApiModelProperty(value = "The date and time when the timing object starts to create triggers.")
  public String getStart() {
    return start;
  }

  public void setStart(String start) {
    this.start = start;
  }

  public InlineResponse200EventsPeriodic end(String end) {
    this.end = end;
    return this;
  }

   /**
   * The date and time when the timing object stops to create triggers.  It is generally a good idea to always configure an end time and to refresh the configuration of timing object as needed to ensure that agents that loose connectivity to their controller do not continue their tasks forever.
   * @return end
  **/
  @ApiModelProperty(value = "The date and time when the timing object stops to create triggers.  It is generally a good idea to always configure an end time and to refresh the configuration of timing object as needed to ensure that agents that loose connectivity to their controller do not continue their tasks forever.")
  public String getEnd() {
    return end;
  }

  public void setEnd(String end) {
    this.end = end;
  }

  public InlineResponse200EventsPeriodic interval(Integer interval) {
    this.interval = interval;
    return this;
  }

   /**
   * The number of seconds between two triggers generated by this periodic timing object.
   * @return interval
  **/
  @ApiModelProperty(required = true, value = "The number of seconds between two triggers generated by this periodic timing object.")
  @NotNull
  public Integer getInterval() {
    return interval;
  }

  public void setInterval(Integer interval) {
    this.interval = interval;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineResponse200EventsPeriodic inlineResponse200EventsPeriodic = (InlineResponse200EventsPeriodic) o;
    return Objects.equals(this.start, inlineResponse200EventsPeriodic.start) &&
        Objects.equals(this.end, inlineResponse200EventsPeriodic.end) &&
        Objects.equals(this.interval, inlineResponse200EventsPeriodic.interval);
  }

  @Override
  public int hashCode() {
    return Objects.hash(start, end, interval);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineResponse200EventsPeriodic {\n");
    
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    interval: ").append(toIndentedString(interval)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

